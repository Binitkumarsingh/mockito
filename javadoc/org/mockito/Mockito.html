<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_06) on Sat Jul 26 20:43:59 CEST 2008 -->
<TITLE>
Mockito (Mockito API)
</TITLE>

<META NAME="date" CONTENT="2008-07-26">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Mockito (Mockito API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Mockito.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/mockito/Matchers.html" title="class in org.mockito"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/mockito/MockitoAnnotations.html" title="class in org.mockito"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?org/mockito/Mockito.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Mockito.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.mockito</FONT>
<BR>
Class Mockito</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../org/mockito/Matchers.html" title="class in org.mockito">org.mockito.Matchers</A>
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>org.mockito.Mockito</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Mockito</B><DT>extends <A HREF="../../org/mockito/Matchers.html" title="class in org.mockito">Matchers</A></DL>
</PRE>

<P>
Enables mocks creation, verification and stubbing.
 
 <h1>Contents</h1>
 
 <b> 
      1. Let's verify some behaviour! <br/> 
      2. How about some stubbing? <br/>
      3. Argument matchers <br/> 
      4. Verifying exact number of invocations / at least once / never <br/> 
      5. Stubbing void methods with exceptions <br/> 
      6. Verification in order <br/> 
      7. Making sure interaction(s) never happened on mock <br/> 
      8. Finding redundant invocations <br/> 
      9. Shorthand for mocks creation - &#064;Mock annotation <br/> 
      10. (**New**) Stubbing consecutive calls (iterator-style stubbing) <br/> 
      11. (**Totally New**) Stubbing with callbacks <br/>
      12. (**Totally New**) doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids <br/>
      13. (**Totally New**) Spying on real objects <br/>
 </b>
 
 <p>
 Following examples mock List, because everyone knows its interface (methods
 like add(), get(), clear() will be used). <br>
 You probably wouldn't mock List class 'in real'.
 
 <h3>1. Let's verify some behaviour!</h3>
 
 <pre>
 //Let's import Mockito statically so that the code looks clearer
 import static org.mockito.Mockito.*;
 
 //mock creation
 List mockedList = mock(List.class);
 
 //using mock object
 mockedList.add("one");
 mockedList.clear();
 
 //verification
 verify(mockedList).add("one");
 verify(mockedList).clear();
 </pre>
 
 <p>
 Once created, mock will remember all invocations. Then you can selectively
 verify whatever interaction you are interested in.
 
 <h3>2. How about some stubbing?</h3>
 
 <pre>
 //You can mock concrete classes, not only interfaces
 LinkedList mockedList = mock(LinkedList.class);
 
 //stubbing
 stub(mockedList.get(0)).toReturn("first");
 stub(mockedList.get(1)).toThrow(new RuntimeException());
 
 //following prints "first"
 System.out.println(mockedList.get(0));
 
 //following throws runtime exception
 System.out.println(mockedList.get(1));
 
 //following prints "null" because get(999) was not stubbed
 System.out.println(mockedList.get(999));
  
 //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
 //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).
 //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
 verify(mockedList).get(0);
 </pre>
 
 <ul>
 <li> By default, for all methods that return value, mock returns null, an
 empty collection or appropriate primitive/primitive wrapper value (e.g: 0,
 false, ... for int/Integer, boolean/Boolean, ...). </li>
 
 <li> Stubbing can be overridden: for example common stubbing can go to
 fixture setup but test methods can override it. </li>
 
 <li> Once stubbed, mocked method will always return stubbed value regardless
 of how many times it is called. </li>
 
 <li> Last stubbing is more important - when you stubbed the same method with
 the same arguments many times. </li>
 
 </ul>
 
 <h3>3. Argument matchers</h3>
 
 <pre>
 //stubbing using built-in anyInt() argument matcher
 stub(mockedList.get(anyInt())).toReturn("element");
 
 //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):
 stub(mockedList.contains(argThat(isValid()))).toReturn("element");
 
 //following prints "element"
 System.out.println(mockedList.get(999));
 
 //<b>you can also verify using argument matcher</b>
 verify(mockedList).get(anyInt());
 </pre>
 
 <p>
 Argument matchers allow flexible verification or stubbing. See the <b>whole
 library of</b> <A HREF="../../org/mockito/Matchers.html" title="class in org.mockito"><CODE>Matchers</CODE></A> including examples of <b>custom argument
 matchers / hamcrest matchers</b>.
 <p>
 <b>Warning:</b>
 <p>
 If you are using argument matchers, <b>all arguments</b> have to be provided
 by matchers.
 <p>
 E.g: (example shows verification but the same applies to stubbing):
 
 <pre>
   verify(mock).someMethod(anyInt(), anyString(), <b>eq("third argument")</b>);
   //above is correct - eq() is also an argument matcher
   
   verify(mock).someMethod(anyInt(), anyString(), <b>"third argument"</b>);
   //above is incorrect - exception will be thrown because third argument is given without argument matcher.
 </pre>
 
 <h3>4. Verifying exact number of invocations / at least once / never</h3>
 
 <pre>
 //using mock 
 mockedList.add("once");
 
 mockedList.add("twice");
 mockedList.add("twice");
 
 mockedList.add("three times");
 mockedList.add("three times");
 mockedList.add("three times");
 
 //following two verifications work exactly the same - times(1) is used by default
 verify(mockedList).add("once");
 verify(mockedList, times(1)).add("once");
 
 //exact number of invocations verification
 verify(mockedList, times(2)).add("twice");
 verify(mockedList, times(3)).add("three times");
 
 //verification using never(). never() is an alias to times(0)
 verify(mockedList, never()).add("never happened");
 
 //verification using atLeastOnce()
 verify(mockedList, atLeastOnce()).add("three times");
 
 </pre>
 
 <p>
 <b>times(1) is the default.</b> Therefore using times(1) explicitly can be
 omitted.
 
 <h3>5. Stubbing void methods with exceptions</h3>
 
 <A HREF="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><CODE>doThrow(Throwable)</CODE></A> replaces <A HREF="../../org/mockito/Mockito.html#stubVoid(T)"><CODE>stubVoid(Object)</CODE></A> because of improved readability and consistency with the family of doAnswer() methods. 
 <p>
 See paragraph 12.
 
 <h3>6. Verification in order</h3>
 
 <pre>
 List firstMock = mock(List.class);
 List secondMock = mock(List.class);
 
 //using mocks
 firstMock.add("was called first");
 secondMock.add("was called second");
 
 //create inOrder object passing any mocks that need to be verified in order
 InOrder inOrder = inOrder(firstMock, secondMock);
 
 //following will make sure that firstMock was called before secondMock
 inOrder.verify(firstMock).add("was called first");
 inOrder.verify(secondMock).add("was called second");
 </pre>
 
 Verification in order is flexible - <b>you don't have to verify all
 interactions</b> one-by-one but only those that you are interested in
 testing in order.
 <p>
 Also, you can create InOrder object passing only mocks that are relevant for
 in-order verification.
 
 <h3>7. Making sure interaction(s) never happened on mock</h3>
 
 <pre>
 //using mocks - only mockOne is interacted
 mockOne.add("one");
 
 //ordinary verification
 verify(mockOne).add("one");
 
 //verify that method was never called on a mock
 verify(mockOne, never()).add("two");
 
 //verify that other mocks were not interacted
 verifyZeroInteractions(mockTwo, mockThree);
 
 </pre>
 
 <p>
 Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions()
 but the first one is more explicit and can read better.
 
 <h3>8. Finding redundant invocations</h3>
 
 <pre>
 //using mocks
 mockedList.add("one");
 mockedList.add("two");
 
 verify(mockedList).add("one");
 
 //following verification will fail 
 verifyNoMoreInteractions(mockedList);
 </pre>
 
 Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. 
 verifyNoMoreInteractions() is not recommended to use in every test method. 
 verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 Abusing it leads to overspecified, less maintainable tests. You can find further reading 
 <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.
 
 <p>   
 
  See also <A HREF="../../org/mockito/Mockito.html#never()"><CODE>never()</CODE></A> - it is more explicit and
 communicates an intent well.
 <p>
 
 <h3>9. Shorthand for mocks creation - &#064;Mock annotation</h3>
 
 <ul>
 <li>Minimizes repetitive mock creation code.</li>
 <li>Makes the test class more readable.</li>
 <li>Makes the verification error easier to read because <b>field name</b>
 is used to identify the mock.</li>
 </ul>
 
 <pre>
   public class ArticleManagerTest { 
     
       &#064;Mock private ArticleCalculator calculator;
       &#064;Mock private ArticleDatabase database;
       &#064;Mock private UserProvider userProvider;
     
       private ArticleManager manager;
 </pre>
 
 <b>Important!</b> This needs to be somewhere in the base class or a test
 runner:
 
 <pre>
 MockitoAnnotations.initMocks(testClass);
 </pre>
 
 Examples how to write a junit test runner are in Mockito test code
 (mockito/test/org/mockitousage/examples/junitrunner package);
 <p>
 Read more here: <A HREF="../../org/mockito/MockitoAnnotations.html" title="class in org.mockito"><CODE>MockitoAnnotations</CODE></A>
 
 <h3> 10. (**New**) Stubbing consecutive calls (iterator-style stubbing)</h3>
 
 Sometimes we need to stub with different return value/exception for the same
 method call. Typical use case could be mocking iterators. 
 Original version of Mockito did not have this feature to promote simple mocking. 
 For example, instead of iterators one could use <CODE>Iterable</CODE> or simply
 collections. Those offer natural ways of stubbing (e.g. using real
 collections). In rare scenarios stubbing consecutive calls could be useful,
 though:
 <p>
 
 <pre>
 stub(mock.someMethod("some arg"))
   .toThrow(new RuntimeException())
   .toReturn("foo");
 
 //First call: throws runtime exception:
 mock.someMethod("some arg");
 
 //Second call: prints "foo"
 System.out.println(mock.someMethod("some arg"));
 
 //Any consecutive call: prints "foo" as well (last stubbing wins). 
 System.out.println(mock.someMethod("some arg"));
 </pre>
 
 <h3> 11. (**Totally New**) Stubbing with callbacks</h3>
 
 Allows stubbing with generic <A HREF="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><CODE>Answer</CODE></A> interface.
  <p>
 Yet another controversial feature which was not included in Mockito
 originally. We recommend using simple stubbing with toReturn() or
 toThrow() only. Those two should be <b>just enough</b> to test/test-drive
 any decent (clean & simple) code.
 
 <pre>
 stub(mock.someMethod(anyString())).toAnswer(new Answer() {
     Object answer(InvocationOnMock invocation) {
         Object[] args = invocation.getArguments();
         Object mock = invocation.getMock();
         return "called with arguments: " + args;
     }
 });
 
 //Following prints "called with arguments: foo"
 System.out.println(mock.someMethod("foo"));
 </pre>
 
 <h3> 12. (**Totally New**) doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>
 
 Stubbing voids requires different approach from <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A> because the compiler does not like void methods inside brackets...
 <p>
 <A HREF="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><CODE>doThrow(Throwable)</CODE></A> replaces the <A HREF="../../org/mockito/Mockito.html#stubVoid(T)"><CODE>stubVoid(Object)</CODE></A> method for stubbing voids. 
 The main reason is improved readability and consistency with the family of doAnswer() methods.
 <p>
 Use doThrow() when you want to stub a void method with an exception:
 <pre>
   doThrow(new RuntimeException()).when(mockedList).clear();
   
   //following throws RuntimeException:
   mockedList.clear();
 </pre>
 
 Read more about other methods:
 <p>
 <A HREF="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><CODE>doThrow(Throwable)</CODE></A>
 <p>
 <A HREF="../../org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer)"><CODE>doAnswer(Answer)</CODE></A>
 <p>
 <A HREF="../../org/mockito/Mockito.html#doNothing()"><CODE>doNothing()</CODE></A>
 <p>
 <A HREF="../../org/mockito/Mockito.html#doReturn(java.lang.Object)"><CODE>doReturn(Object)</CODE></A>
 
 <h3> 13. (**Totally New**) Spying on real objects</h3>
 
 You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).
 <p>
 Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
 <p>
 Spying on real objects is associated with "partial mocking" concept. 
 
 <pre>
   List list = new LinkedList();
   List spy = spy(list);
 
   //optionally, you can stub out some methods:
   stub(spy.size()).toReturn(100);
 
   //using the spy calls <b>real</b> methods
   spy.add("one");
   spy.add("two");
 
   //prints "one" - the first element of a list
   System.out.println(spy.get(0));
 
   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());
 
   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
 </pre>
 
 <h4>Important gotcha on spying real objects!</h4>
 
 Sometimes it's impossible to use <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A> for stubbing spies. Example:
 
 <pre>
   List list = new LinkedList();
   List spy = spy(list);
   
   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   stub(spy.get(0)).toReturn("foo");
   
   //You have to use doReturn() for stubbing
   doReturn("foo").when(spy).get(0);
 </pre>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#Mockito()">Mockito</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#atLeastOnce()">atLeastOnce</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows at-least-once verification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer)">doAnswer</A></B>(<A HREF="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</A>&nbsp;answer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use doAnswer() when you want to stub a void method with generic <A HREF="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><CODE>Answer</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#doNothing()">doNothing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use doNothing() for setting void methods to do nothing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#doReturn(java.lang.Object)">doReturn</A></B>(java.lang.Object&nbsp;toBeReturned)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use doReturn() in those rare occasions when you cannot use <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)">doThrow</A></B>(java.lang.Throwable&nbsp;toBeThrown)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use doThrow() when you want to stub the void method with an exception.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/InOrder.html" title="interface in org.mockito">InOrder</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#inOrder(java.lang.Object...)">inOrder</A></B>(java.lang.Object...&nbsp;mocks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates InOrder object that allows verifying mocks in order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#mock(java.lang.Class)">mock</A></B>(java.lang.Class&lt;T&gt;&nbsp;classToMock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates mock object of given class or interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#mock(java.lang.Class, java.lang.String)">mock</A></B>(java.lang.Class&lt;T&gt;&nbsp;classToMock,
     java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates mock with a name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#never()">never</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alias to times(0), see <A HREF="../../org/mockito/Mockito.html#times(int)"><CODE>times(int)</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#spy(T)">spy</A></B>(T&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a spy of the real object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../org/mockito/internal/progress/OngoingStubbing.html" title="interface in org.mockito.internal.progress">OngoingStubbing</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#stub(T)">stub</A></B>(T&nbsp;methodCall)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stubs with return value or exception.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../org/mockito/internal/stubbing/VoidMethodStubbable.html" title="interface in org.mockito.internal.stubbing">VoidMethodStubbable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#stubVoid(T)">stubVoid</A></B>(T&nbsp;mock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use <A HREF="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><CODE>doThrow(Throwable)</CODE></A> method for stubbing voids</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#times(int)">times</A></B>(int&nbsp;wantedNumberOfInvocations)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows verifying exact number of invocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#verify(T)">verify</A></B>(T&nbsp;mock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifies certain behavior <b>happened once</b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#verify(T, org.mockito.internal.progress.VerificationMode)">verify</A></B>(T&nbsp;mock,
       <A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A>&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifies certain behavior happened at least once / exact number of times / never.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)">verifyNoMoreInteractions</A></B>(java.lang.Object...&nbsp;mocks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throws an AssertionError if any of given mocks has any unverified
 interaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)">verifyZeroInteractions</A></B>(java.lang.Object...&nbsp;mocks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifies that no interactions happened on given mocks.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.mockito.Matchers"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.mockito.<A HREF="../../org/mockito/Matchers.html" title="class in org.mockito">Matchers</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../org/mockito/Matchers.html#anyBoolean()">anyBoolean</A>, <A HREF="../../org/mockito/Matchers.html#anyByte()">anyByte</A>, <A HREF="../../org/mockito/Matchers.html#anyChar()">anyChar</A>, <A HREF="../../org/mockito/Matchers.html#anyCollection()">anyCollection</A>, <A HREF="../../org/mockito/Matchers.html#anyDouble()">anyDouble</A>, <A HREF="../../org/mockito/Matchers.html#anyFloat()">anyFloat</A>, <A HREF="../../org/mockito/Matchers.html#anyInt()">anyInt</A>, <A HREF="../../org/mockito/Matchers.html#anyList()">anyList</A>, <A HREF="../../org/mockito/Matchers.html#anyLong()">anyLong</A>, <A HREF="../../org/mockito/Matchers.html#anyMap()">anyMap</A>, <A HREF="../../org/mockito/Matchers.html#anyObject()">anyObject</A>, <A HREF="../../org/mockito/Matchers.html#anyShort()">anyShort</A>, <A HREF="../../org/mockito/Matchers.html#anyString()">anyString</A>, <A HREF="../../org/mockito/Matchers.html#argThat(org.hamcrest.Matcher)">argThat</A>, <A HREF="../../org/mockito/Matchers.html#booleanThat(org.hamcrest.Matcher)">booleanThat</A>, <A HREF="../../org/mockito/Matchers.html#byteThat(org.hamcrest.Matcher)">byteThat</A>, <A HREF="../../org/mockito/Matchers.html#charThat(org.hamcrest.Matcher)">charThat</A>, <A HREF="../../org/mockito/Matchers.html#contains(java.lang.String)">contains</A>, <A HREF="../../org/mockito/Matchers.html#doubleThat(org.hamcrest.Matcher)">doubleThat</A>, <A HREF="../../org/mockito/Matchers.html#endsWith(java.lang.String)">endsWith</A>, <A HREF="../../org/mockito/Matchers.html#eq(boolean)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(byte)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(char)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(double)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(float)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(int)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(long)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(short)">eq</A>, <A HREF="../../org/mockito/Matchers.html#eq(T)">eq</A>, <A HREF="../../org/mockito/Matchers.html#floatThat(org.hamcrest.Matcher)">floatThat</A>, <A HREF="../../org/mockito/Matchers.html#intThat(org.hamcrest.Matcher)">intThat</A>, <A HREF="../../org/mockito/Matchers.html#isA(java.lang.Class)">isA</A>, <A HREF="../../org/mockito/Matchers.html#isNotNull()">isNotNull</A>, <A HREF="../../org/mockito/Matchers.html#isNull()">isNull</A>, <A HREF="../../org/mockito/Matchers.html#longThat(org.hamcrest.Matcher)">longThat</A>, <A HREF="../../org/mockito/Matchers.html#matches(java.lang.String)">matches</A>, <A HREF="../../org/mockito/Matchers.html#notNull()">notNull</A>, <A HREF="../../org/mockito/Matchers.html#refEq(T)">refEq</A>, <A HREF="../../org/mockito/Matchers.html#same(T)">same</A>, <A HREF="../../org/mockito/Matchers.html#shortThat(org.hamcrest.Matcher)">shortThat</A>, <A HREF="../../org/mockito/Matchers.html#startsWith(java.lang.String)">startsWith</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Mockito()"><!-- --></A><H3>
Mockito</H3>
<PRE>
public <B>Mockito</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="mock(java.lang.Class)"><!-- --></A><H3>
mock</H3>
<PRE>
public static &lt;T&gt; T <B>mock</B>(java.lang.Class&lt;T&gt;&nbsp;classToMock)</PRE>
<DL>
<DD>Creates mock object of given class or interface.
 <p>
 
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>classToMock</CODE> - class or interface to mock
<DT><B>Returns:</B><DD>mock object</DL>
</DD>
</DL>
<HR>

<A NAME="mock(java.lang.Class, java.lang.String)"><!-- --></A><H3>
mock</H3>
<PRE>
public static &lt;T&gt; T <B>mock</B>(java.lang.Class&lt;T&gt;&nbsp;classToMock,
                         java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Creates mock with a name. Naming mocks can be helpful for debugging. 
 <p>
 Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. In that case we recommend merciless refactoring.
 <p>
 If you use &#064;Mock annotation then you've got naming mocks for free. &#064;Mock uses field name as mock name.
 <p>
 
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>classToMock</CODE> - class or interface to mock
<DT><B>Returns:</B><DD>mock object</DL>
</DD>
</DL>
<HR>

<A NAME="spy(java.lang.Object)"><!-- --></A><A NAME="spy(T)"><!-- --></A><H3>
spy</H3>
<PRE>
public static &lt;T&gt; T <B>spy</B>(T&nbsp;object)</PRE>
<DL>
<DD>Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
 <p>
 Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
 <p>
 Spying on real objects is associated with "partial mocking" concept.
 <p>
 Example:
 
 <pre>
   List list = new LinkedList();
   List spy = spy(list);
 
   //optionally, you can stub out some methods:
   stub(spy.size()).toReturn(100);
 
   //using the spy calls <b>real</b> methods
   spy.add("one");
   spy.add("two");
 
   //prints "one" - the first element of a list
   System.out.println(spy.get(0));
 
   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());
 
   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
 </pre>
 
 <h4>Important gotcha on spying real objects!</h4>
 
 Sometimes it's impossible to use <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A> for stubbing spies. Example:
 
 <pre>
   List list = new LinkedList();
   List spy = spy(list);
   
   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   stub(spy.get(0)).toReturn("foo");
   
   //You have to use doReturn() for stubbing
   doReturn("foo").when(spy).get(0);
 </pre>
 
 <p>
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - to spy on
<DT><B>Returns:</B><DD>a spy of the real object</DL>
</DD>
</DL>
<HR>

<A NAME="stub(java.lang.Object)"><!-- --></A><A NAME="stub(T)"><!-- --></A><H3>
stub</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../org/mockito/internal/progress/OngoingStubbing.html" title="interface in org.mockito.internal.progress">OngoingStubbing</A>&lt;T&gt; <B>stub</B>(T&nbsp;methodCall)</PRE>
<DL>
<DD>Stubs with return value or exception. E.g:
 
 <pre>
   stub(mock.someMethod()).toReturn(10);
   
   //you can use flexible argument matchers, e.g:
   stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);
   
   //setting exception to be thrown:
   stub(mock.someMethod("some arg")).toThrow(new RuntimeException());
   
   //you can stub with different behavior for consecutive calls.
   //Last stubbing (e.g: toReturn("foo")) determines the behavior for further consecutive calls.   
   stub(mock.someMethod("some arg"))
    .toThrow(new RuntimeException())
    .toReturn("foo");
   
 </pre>
 
 For stubbing void methods with throwables see: <A HREF="../../org/mockito/Mockito.html#stubVoid(T)"><CODE>stubVoid(T)</CODE></A>
 <p>
 Stubbing can be overridden: for example common stubbing can go to fixture
 setup but test methods can override it.
 <p>
 Once stubbed, mocked method will always return stubbed value regardless
 of how many times it is called.
 <p>
 Last stubbing is more important - when you stubbed the same method with
 the same arguments many times.
 <p>
 Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 Let's say you've stubbed foo.bar(). 
 If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).
 If your code doesn't care what get(0) returns then it should not be stubbed. 
 Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
 
 <p>
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>methodCall</CODE> - method call
<DT><B>Returns:</B><DD>OngoingStubbing object to set stubbed value/exception</DL>
</DD>
</DL>
<HR>

<A NAME="verify(java.lang.Object)"><!-- --></A><A NAME="verify(T)"><!-- --></A><H3>
verify</H3>
<PRE>
public static &lt;T&gt; T <B>verify</B>(T&nbsp;mock)</PRE>
<DL>
<DD>Verifies certain behavior <b>happened once</b> 
 <p>
 Alias to <code>verify(mock, times(1))</code> E.g:
 <pre>
   verify(mock).someMethod("some arg");
 </pre>
 Above is equivalent to:
 <pre>
   verify(mock, times(1)).someMethod("some arg");
 </pre>
 
 <p>
 Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 Let's say you've stubbed foo.bar(). 
 If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).
 If your code doesn't care what get(0) returns then it should not be stubbed. 
 Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
 
 <p>
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mock</CODE> - to be verified
<DT><B>Returns:</B><DD>mock object itself</DL>
</DD>
</DL>
<HR>

<A NAME="verify(java.lang.Object,org.mockito.internal.progress.VerificationMode)"><!-- --></A><A NAME="verify(T, org.mockito.internal.progress.VerificationMode)"><!-- --></A><H3>
verify</H3>
<PRE>
public static &lt;T&gt; T <B>verify</B>(T&nbsp;mock,
                           <A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A>&nbsp;mode)</PRE>
<DL>
<DD>Verifies certain behavior happened at least once / exact number of times / never. E.g:
 <pre>
   verify(mock, times(5)).someMethod("was called five times");
   
   verify(mock, atLeastOnce()).someMethod("was called at least once");
   
   //you can use flexible argument matchers, e.g:
   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);
 </pre>
 
 <b>times(1) is the default</b> and can be omitted
 <p>
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mock</CODE> - to be verified<DD><CODE>mode</CODE> - times(x), atLeastOnce() or never()
<DT><B>Returns:</B><DD>mock object itself</DL>
</DD>
</DL>
<HR>

<A NAME="verifyNoMoreInteractions(java.lang.Object...)"><!-- --></A><H3>
verifyNoMoreInteractions</H3>
<PRE>
public static void <B>verifyNoMoreInteractions</B>(java.lang.Object...&nbsp;mocks)</PRE>
<DL>
<DD>Throws an AssertionError if any of given mocks has any unverified
 interaction.
 <p>
 You can use this method after you verified your mocks - to make sure that nothing
 else was invoked on your mocks.
 <p>
 See also <A HREF="../../org/mockito/Mockito.html#never()"><CODE>never()</CODE></A> - it is more explicit and communicates an intent well.
 <p>
 Stubbed invocations (if called) are also treated as interactions.
 <p>
 Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. 
 verifyNoMoreInteractions() is not recommended to use in every test method. 
 verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 Abusing it leads to overspecified, less maintainable tests. You can find further reading 
 <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.
 
 <p>
 Example:
 
 <pre>
 //interactions
 mock.doSomething();
 mock.doSomethingUnexpected();
 
 //verification
 verify(mock).doSomething();
 
 //following will fail because 'doSomethingUnexpected()' is unexpected
 verifyNoMoreInteractions(mock);
 
 </pre>
 
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mocks</CODE> - to be verified</DL>
</DD>
</DL>
<HR>

<A NAME="verifyZeroInteractions(java.lang.Object...)"><!-- --></A><H3>
verifyZeroInteractions</H3>
<PRE>
public static void <B>verifyZeroInteractions</B>(java.lang.Object...&nbsp;mocks)</PRE>
<DL>
<DD>Verifies that no interactions happened on given mocks.
 <pre>
   verifyZeroInteractions(mockOne, mockTwo);
 </pre>
 
 Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but 
 the first one is more explicit and can read better.
 <p>
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mocks</CODE> - to be verified</DL>
</DD>
</DL>
<HR>

<A NAME="stubVoid(java.lang.Object)"><!-- --></A><A NAME="stubVoid(T)"><!-- --></A><H3>
stubVoid</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../org/mockito/internal/stubbing/VoidMethodStubbable.html" title="interface in org.mockito.internal.stubbing">VoidMethodStubbable</A>&lt;T&gt; <B>stubVoid</B>(T&nbsp;mock)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use <A HREF="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><CODE>doThrow(Throwable)</CODE></A> method for stubbing voids</I>
<P>
<DD><b>Deprecated</b>
 
 <pre>
   //Instead of:
   stubVoid(mock).toThrow(e).on().someVoidMethod();
 
   //Please do:
   doThrow(e).when(mock).someVoidMethod();
 </pre> 
 
 doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. 
 <p>
 Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:
 
 <pre>
 stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();
 
 //you can stub with different behavior for consecutive calls.
 //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   
 stub(mock)
   .toThrow(new RuntimeException())
   .toReturn()
   .on().someMethod();
 </pre>
 
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mock</CODE> - to stub
<DT><B>Returns:</B><DD>stubbable object that allows stubbing with throwable</DL>
</DD>
</DL>
<HR>

<A NAME="doThrow(java.lang.Throwable)"><!-- --></A><H3>
doThrow</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A> <B>doThrow</B>(java.lang.Throwable&nbsp;toBeThrown)</PRE>
<DL>
<DD>Use doThrow() when you want to stub the void method with an exception.
 <p>
 Stubbing voids requires different approach from <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A> because the compiler does not like void methods inside brackets...
 <p>
 Example:
 
 <pre>
   doThrow(new RuntimeException()).when(mock).someVoidMethod();
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeThrown</CODE> - to be thrown when the stubbed method is called
<DT><B>Returns:</B><DD>stubber - to select a method for stubbing</DL>
</DD>
</DL>
<HR>

<A NAME="doAnswer(org.mockito.stubbing.Answer)"><!-- --></A><H3>
doAnswer</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A> <B>doAnswer</B>(<A HREF="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</A>&nbsp;answer)</PRE>
<DL>
<DD>Use doAnswer() when you want to stub a void method with generic <A HREF="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><CODE>Answer</CODE></A>.
 <p>
 Stubbing voids requires different approach from <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A> because the compiler does not like void methods inside brackets...
 <p>
 Example:
 
 <pre>
  doAnswer(new Answer() {
      public Object answer(InvocationOnMock invocation) {
          Object[] args = invocation.getArguments();
          Mock mock = invocation.getMock();
          return null;
      }})
  .when(mock).someMethod();
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>answer</CODE> - to answer when the stubbed method is called
<DT><B>Returns:</B><DD>stubber - to select a method for stubbing</DL>
</DD>
</DL>
<HR>

<A NAME="doNothing()"><!-- --></A><H3>
doNothing</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A> <B>doNothing</B>()</PRE>
<DL>
<DD>Use doNothing() for setting void methods to do nothing. <b>Beware</b> that void methods do nothing by default! 
 However, there are rare situations when doNothing() comes handy:  
 <p>
 1. Stubbing consecutive calls on a void method:
 <pre>
   doNothing().
   doThrow(new RuntimeException())
   .when(mock).someVoidMethod();
   
   //does nothing the first time:
   mock.someVoidMethod();
   
   //throws RuntimeException the next time:
   mock.someVoidMethod();
 </pre>
 
 2. When you spy real objects and you want the void method to do nothing:
 <pre>
   List list = new LinkedList();
   List spy = spy(list);
   
   //let's make clear() do nothing
   doNothing().when(spy).clear();
   
   spy.add("one");
   
   //clear() does nothing, so the list still contains "one"
   spy.clear();
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>stubber - to select a method for stubbing</DL>
</DD>
</DL>
<HR>

<A NAME="doReturn(java.lang.Object)"><!-- --></A><H3>
doReturn</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/stubbing/Stubber.html" title="interface in org.mockito.internal.stubbing">Stubber</A> <B>doReturn</B>(java.lang.Object&nbsp;toBeReturned)</PRE>
<DL>
<DD>Use doReturn() in those rare occasions when you cannot use <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A>.
 <p>
 Beware that <A HREF="../../org/mockito/Mockito.html#stub(T)"><CODE>stub(Object)</CODE></A> is <b>always recommended</b> for stubbing because it is argument type-safe 
 and more readable (especially when stubbing consecutive calls). 
 <p>
 However, there are occasions when doReturn() comes handy:
 <p>
 
 1. When spying real objects and calling real methods on a spy brings side effects  
 
 <pre>
   List list = new LinkedList();
   List spy = spy(list);
   
   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   stub(spy.get(0)).toReturn("foo");
   
   //You have to use doReturn() for stubbing:
   doReturn("foo").when(spy).get(0);
 </pre>
 
 2. Overriding a previous exception-stubbing:
 
 <pre>
   stub(mock.foo()).toThrow(new RuntimeException());
   
   //Impossible: the exception-stubbed foo() method is really called so RuntimeException is thrown. 
   stub(mock.foo()).toReturn("bar");
   
   //You have to use doReturn() for stubbing:
   doReturn("bar").when(mock).foo();
 </pre>
 
 Above scenario shows a tradeoff of Mockito's ellegant syntax. The scenario is very rare, though.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeReturned</CODE> - to be returned when the stubbed method is called
<DT><B>Returns:</B><DD>stubber - to select a method for stubbing</DL>
</DD>
</DL>
<HR>

<A NAME="inOrder(java.lang.Object...)"><!-- --></A><H3>
inOrder</H3>
<PRE>
public static <A HREF="../../org/mockito/InOrder.html" title="interface in org.mockito">InOrder</A> <B>inOrder</B>(java.lang.Object...&nbsp;mocks)</PRE>
<DL>
<DD>Creates InOrder object that allows verifying mocks in order.
 
 <pre>
   InOrder inOrder = inOrder(firstMock, secondMock);
   
   inOrder.verify(firstMock).add("was called first");
   inOrder.verify(secondMock).add("was called second");
 </pre>
 
 Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one
 but only those that you are interested in testing in order.
 <p>
 Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  

 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mocks</CODE> - to be verified in order
<DT><B>Returns:</B><DD>InOrder object to be used to verify in order</DL>
</DD>
</DL>
<HR>

<A NAME="atLeastOnce()"><!-- --></A><H3>
atLeastOnce</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A> <B>atLeastOnce</B>()</PRE>
<DL>
<DD>Allows at-least-once verification. E.g:
 <pre>
   verify(mock, atLeastOnce()).someMethod("some arg");
 </pre>
 
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>

<DT><B>Returns:</B><DD>verification mode</DL>
</DD>
</DL>
<HR>

<A NAME="times(int)"><!-- --></A><H3>
times</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A> <B>times</B>(int&nbsp;wantedNumberOfInvocations)</PRE>
<DL>
<DD>Allows verifying exact number of invocations. E.g:
 <pre>
   verify(mock, times(2)).someMethod("some arg");
 </pre>
 
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>wantedNumberOfInvocations</CODE> - wanted number of invocations
<DT><B>Returns:</B><DD>verification mode</DL>
</DD>
</DL>
<HR>

<A NAME="never()"><!-- --></A><H3>
never</H3>
<PRE>
public static <A HREF="../../org/mockito/internal/progress/VerificationMode.html" title="interface in org.mockito.internal.progress">VerificationMode</A> <B>never</B>()</PRE>
<DL>
<DD>Alias to times(0), see <A HREF="../../org/mockito/Mockito.html#times(int)"><CODE>times(int)</CODE></A>
 <p>
 Verifies that interaction did not happen
 <pre>
   verify(mock, never()).someMethod();
 </pre>
 
 <p>
 See examples in javadoc for <A HREF="../../org/mockito/Mockito.html" title="class in org.mockito"><CODE>Mockito</CODE></A> class
<P>
<DD><DL>

<DT><B>Returns:</B><DD>verification mode</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Mockito.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/mockito/Matchers.html" title="class in org.mockito"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/mockito/MockitoAnnotations.html" title="class in org.mockito"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?org/mockito/Mockito.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Mockito.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
